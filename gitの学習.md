# Git

# git の学習

## git の概要

### git が解決する問題

ファイルを元の状態へ戻したい場合は一番簡単なのは事前に編集前のバックアップを用意しておくことであるが手間もかかる上に間違いも発生しやすい。そういった問題を解決するために Git が生まれた。Git を使用するとファイルの状態を`更新履歴`として保存しておくことが可能でファイルを過去の状態へ戻したり編集箇所の差分を表示することができる。

### コミット

Git ではファイル管理をリモートリポジトリと自身の PC にあるローカルリポジトリを使用して行う。 ローカルリポジトリを編集し push してリモートに反映、リモートを pull してローカルに反映する。 ファイルやディレクトリの追加および変更をリポジトリに記録する操作を`コミット`という。 コミットは時系列順に格納されており、リポジトリに格納されているのでコミットを最新のものから辿ることで過去の変更履歴を把握できる。

### ワークツリーとインデックス(ステージ)

- ワークツリー: Git 管理下に置かれた実際に作業をしているディレクトリのこと。

- インデックス： 別名ステージングとも呼ばれ、レポジトリとワークツリーの間に存在するコミット前の準備場所。 厳密にはインデックスはワーキングツリーの内容のスナップショットを保持している。次回コミットされるときにコンテンツとして保存されるのが このスナップショットに当たる。 Git では、コミットを実行した際にワークツリーから直接レポジトリ内に状態を記録するのではなく、その間に設けられているインデックスの状態を記録するようになっている。

※スナップショット： ある瞬間を切り取ったものを指す。コミットを写真を撮るに例えた場合、ステージングは物を撮影台の上に置くイメージ。

### ステージングについて少しの深掘り

### インデックス(ステージング)に git add であげる行為は何を意味するのか？

ワークツリーで git add されたファイルは実際には

- .git/index(インデックス)
- .git/objects(レポジトリのデータベース)

に書き込まれる。

.git/index にはファイルのメタ情報的なものが格納されており、.git/objects にはファイルそのものが格納されている。つまり git add した時点でコンテンツはレポジトリに格納されていると言える。

参考リンク

[Git のステージング領域の正体を探る](https://engineering.mercari.com/blog/entry/2017-04-06-171430/)

## ブランチ

ソフトウェアの開発では一つのソフトウェアに対して複数のメンバーが同時に追加やバグ修正などを行うことがあり、こういったことを支援するために Git にはブランチという機能が備わっている。

基本的な作業についてチームのメンバーは他メンバーの開発の影響を受けないようにメインのブランチから自分の作業用ブランチを作成する。作業が終わったメンバーはメインのブランチに自分のブランチの変更を取り込むようにする。このように作業単位で履歴をブランチとして残すことで問題が発生した場合に原因となる変更箇所の調査や対策を行うことが容易になる。

### ブランチの運用

- 統合ブランチ: リリース版がいつでも作成可能なようにしておくためのブランチ。安定した状態を保っておくことが重要である。基本的にこのブランチからトピックブランチを作成して作業を行うことが多い。Jenkins 等の CI ツールを使用した自動ビルドやテストはこのブランチを使う。
- トピックブランチ: 機能追加やバグ修正といった課題に関する作業を行うために作成するブランチ。複数の課題に関する作業を同時に行う場合はその個数分のトピックブランチが作成される。

### Git の HEAD とは何？ ブランチとは何？

- HEAD

今自分が作業をしている場所を示すポインタである。

- Branch

開発の本流から分岐し、本流の開発を邪魔することなく作業を続ける機能。

Git においてブランチとは単にコミットを指す軽量なポインタである。

なので master,develop,feature とブランチが 3 つ分かれている場合、それぞれのブランチは特定のコミットを示すポインタである。

勘違いするパターンとしてはブランチを派生元から最新の履歴までの枝全体、ファイル群のようなものをさし示しているパターンである。(要は最新のコミットだけでそれ以外はブランチとは言わない。＃)

### Git のコミット時の内部的な処理

コマンドで下記を実行した際に Git では内部的にどのようなことが起こっているか。

git add .

git commit -v “first- commit”

1. ステージされたファイルのハッシュを計算
   1. ファイル A・・・5b1b3
   2. ファイル B・・・4gh76
   3. ファイル C・・・9ijb4
2. ツリーオブジェクトが作成される
3. ツリーオブジェクトにステージしたコードのスナップショットへのポインタが格納される
4. git commit が実行されるとコミットオブジェクトを作成
5. コミットオブジェクトにツリーオブジェクトへのポインタ、親コミットへのポインタ、作成者のメタデータなどが格納される
6. ブランチのポインタを最新のコミットオブジェクトに進める

コミットが繰り返されるごとにブランチは次のブランチに自動で移動する。

合わせて HEAD も移動する。

### HEAD

HEAD の中身もポインタである。

HEAD がブランチを指すことで自分が今どこのブランチにいるかを確認することができるようになっている。つまりコミットの場所を記憶しているのがブランチ、ブランチの場所を記憶しているのが HEAD である。

[Git の HEAD とは何者なのか - Qiita](https://qiita.com/ymzkjpx/items/00ff664da60c37458aaa)

### stash

まだコミットしていない変更内容や新しく追加したファイルがインデックス、ワークツリーに残ったままで他ブランチへチェックアウト(ブランチの移動)すると変更内容は元のブランチから移動先のブランチに対して移動する。ただし移動先のブランチで同じファイルがすでに何らかの変更が行われている場合はチェックアウトに失敗してしまう。こういった場合には stash を利用して一時的に変更内容を対比させてからチェックアウトする必要がある。

[【git stash】コミットはせずに変更を退避したいとき - Qiita](https://qiita.com/chihiro/items/f373873d5c2dfbd03250)

## ブランチの統合

作業が完了したトピックブランチは統合ブランチ(安定したブランチ)へ統合される。ブランチの統合には下記の２種類がある。どちらを使うかによって統合後のブランチの履歴が大きく異なる。

- merge : 合流

慣れていなくても使いやすい。

- rebase : 付け替え

git log(綺麗) が綺麗になる
